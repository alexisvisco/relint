# Architecture

- {module} : Name of a server e.g. assetserver, smarthubserver ...
  - types/ : Where domains types belongs
  - {name}service/ : Services are responsible for providing business logic, they work with the store, other services and return types
  - {name}store/ : Stores are responsible for data persistence, they work with the core/model types and return domain types
  - storemapper : Used by the stores to map the core/model types to domain types
  - handler/ : Handlers are responsible for handling the incoming requests, they work with the services and use huma.rocks
- core
  - model/ : Types coupled with the database, they reflect the database schema, they are used by the stores
  - clog/ : Clog is a library used to do canonical logging, used in the http layer. Underlying it use log/slog (they are firstly generated by a cli and they maintained by ourself)
  - factory : Factories are 1-1 with the core/model types, they are used to create instances of the core/model types for testing (they are auto generated)
  - testutil : Test utilities, they are used to create instances of the domain types for testing (they are auto generated)
  - dbutil : Database utilities, they are used to works with db in ctx, transactions, provide tenant database through http request
  - testdata : Fixtures for testing and dump.sql for database schema from the python app generated by the cli
- cli: Cli application to operate dev task or perform operations on the services


### File organization

Declarations within a file SHOULD follow this order:
1. `type`
2. `const`
3. `var`
4. `func`

### Logging

- Log keys MUST be in `lowercase_snake_case`
- Log messages MUST start with a lowercase letter
- Keys that belong to a group MUST use dot notation e.g. `error.message`, `error.code`, `user.id`

Do:
```go
slog.Info("user session created", "user.id", user.ID, "session.id", session.ID)
slog.Error("failed to create session", "error.message", err.Error(), "user.id", user.ID)
```

Don't:
```go
slog.Info("User session created", "UserID", user.ID, "SessionID", session.ID)
slog.Error("Failed to create session", "error", err.Error(), "userId", user.ID)
```

### Functions
- Functions that accept a context MUST have `context.Context` as their first parameter
- Functions with more than 4 parameters SHOULD be avoided, consider using a struct with Params suffix e.g. CreateUserParams, UpdateUserParams ...
- Functions with more than 2 return values SHOULD be avoided, consider using a struct with Result suffix e.g. CreateUserResult, UpdateUserResult ...
- Functions referenced in `fx.Provide(...)` MAY return more than 2 values when needed for DI wiring

### Types declaration merging

Do:
```go
type (
	AuthenticateUserResult struct {
		...
	}

	AuthServiceCompleteInvitationParams struct {
		...
	}
)
```

Don't:
```go
type AuthenticateUserResult struct {
    ...
}

type AuthServiceCompleteInvitationParams struct {
    ...
}
```

Types in a declaration block MUST be separated by a blank line.

### Spacing

Do:
```go
func (s *UserService) CreateUser(ctx context.Context, params CreateUserParams) (*CreateUserResult, error) {
    user, err := s.store.CreateUser(ctx, store.CreateUserParams{
        ...
    })
    if err != nil {
        return nil, err
    }

    return &CreateUserResult{
        User: user,
    }, nil
}
```

Don't:
```go
func (s *UserService) CreateUser(ctx context.Context, params CreateUserParams) (*CreateUserResult, error) {

    user, err := s.store.CreateUser(ctx, store.CreateUserParams{
        ...
    })

    if err != nil {
        return nil, err
    }

    return &CreateUserResult{
        User: user,
    }, nil

}
```

- Logical blocks MUST be kept together; extra space between them MUST NOT be added.
- Functions MUST NOT start or end with empty lines.

### Enum naming

- Enum values MUST be prefixed with their type name

  Do:
  ```go
  type MediaServiceResourceKind string
  
  const (
      MediaServiceResourceKindCompanyLogo MediaServiceResourceKind = "company_logo"
      MediaServiceResourceKindClientLogo  MediaServiceResourceKind = "client_logo"
  )
  ```

  Don't:
  ```go
  type MediaServiceResourceKind string
  
  const (
      CompanyLogo MediaServiceResourceKind = "company_logo"
      ClientLogo  MediaServiceResourceKind = "client_logo"
  )
  ```

### Package naming

- Package names MUST NOT use underscores (default excluded suffix: `_test`; additional exclusions MAY be configured)
- Package names MUST NOT be pluralized e.g. `handler` not `handlers`
- Package names SHOULD be short

### Types naming

- Service and Store interfaces MUST be defined in `{module}/types/`
- Other interfaces MAY be defined near their usage
- Service interfaces MUST be suffixed with `Service` e.g. `AuthService`, `UserService` ...
- Store interfaces MUST be suffixed with `Store` e.g. `UserStore`, `LoanStore` ...
- Interface method signatures MUST be separated by a blank line

  Do:
  ```go
  type EventService interface {
      List(ctx context.Context, opts EventListOptions) (*Page[*Event], error)
  
      ListDefinitions(ctx context.Context, opts EventListDefinitionsOptions) ([]*EventDefinition, error)
  
      Ingest(ctx context.Context, opts EventIngestOptions) error
  }
  ```

  Don't:
  ```go
  type EventService interface {
      List(ctx context.Context, opts EventListOptions) (*Page[*Event], error)
      ListDefinitions(ctx context.Context, opts EventListDefinitionsOptions) ([]*EventDefinition, error)
      Ingest(ctx context.Context, opts EventIngestOptions) error
  }
  ```

### Middleware conventions

- A middleware in `{module}/handler` that provides a value in the context MUST be named `Inject{Name}` e.g. `InjectUser`, `InjectTenant`, and its file MUST be named `inject_{name}.go`
- A middleware in `{module}/handler` that validates something MUST be named `Require{Name}` e.g. `RequireAuth`, `RequireAdmin`, and its file MUST be named `require_{name}.go`
- A middleware not in `{module}/handler` MUST be named `Middleware` and SHOULD be in a file named `{name}_http_support.go`
- A middleware not in `{module}/handler` SHOULD be a stdlib http middleware e.g. `clog.Middleware`, `dbutil.Middleware` ...

### fx_module.go

- Every layer (store, service, handler) MUST have an `fx_module.go` in its package
- `fx_module.go` MUST be in the same package as the layer struct it provides
- `fx_module.go` MUST export a `FxModule` variable e.g.:
    ```go
    var FxModule = fx.Module("handler",
        fx.Provide(NewAuthHandler),
        fx.Provide(NewTenantHandler),
        fx.Invoke(setupRoutes),
    )
    ```

### Store

- `store.go` MUST contain the store struct definition
- The constructor MUST be exported, the struct MUST be exported, and MUST assert interface implementation e.g. `var _ types.UserStore = (*UserStore)(nil)`
- `{function_name}.go` SHOULD contain a single primary exported store method; avoid multiple exported `*Store` methods in one file
- Store functions MUST return domain types through the storemapper, NOT core/model types
- Store functions SHOULD NOT use transactions
- RecordNotFound MUST be a typed domain error e.g. `types.ErrUserNotFound`

### Service

- `service.go` MUST contain the service struct definition
- The constructor MUST be exported, the struct MUST be exported, and MUST assert interface implementation e.g. `var _ types.UserService = (*UserService)(nil)`
- `{function_name}.go` SHOULD contain a single primary exported service method; avoid multiple exported `*Service` methods in one file
- Service functions MUST return domain types
- Service functions MUST validate inputs with `github.com/alexisvisco/valid`
- Service functions MUST orchestrate store calls; transactions MUST be placed here when needed
- Service functions MUST NOT hide unexpected errors; if an error is unexpected it MUST be returned

### Handler

- `fx_module.go` MUST invoke a setup function that registers the routes and handlers
- `fx_module.go` MUST define mapped http status codes for domain errors
- `{name}.go` MUST define a {Name}Handler struct with a public constructor, the setup function, and shared body types
- The handler MUST define func (h *{Name}Handler) setup(api huma.API) to be used in the fx_module
- Route methods MUST live in `{name}_{route}_handler.go` (special case: if route name equals handler base name, use `{name}_handler.go`):
    ```go
    type (
        CompleteInvitationInput struct {
            ...
        }

        CompleteInvitationOutput struct {
            ...
        }
    )

    func (h *AuthHandler) CompleteInvitation(ctx context.Context, input *CompleteInvitationInput) (*CompleteInvitationOutput, error) {
        ...
    }
    ```
- Handlers SHOULD work with services and MAY exceptionally work directly with stores when there is no business logic for read ops
- Route-specific `{Route}Input` and `{Route}Output` types SHOULD be defined in the route file; they MAY live in `{name}.go` when shared across route files
- Body types shared across routes MUST be defined in `{name}.go` and named `{Name}Body{Input|Output}` e.g. `TenantBodyOutput`, `InvitationTokenBodyOutput`; route outputs then reference them via `Body {Name}BodyOutput`
- Structs used only inside `{Name}BodyInput`/`{Name}BodyOutput` SHOULD keep the parent body prefix and matching `Input`/`Output` suffix (e.g. `InvitationTokenBodyClientOutput` under `InvitationTokenBodyOutput`)
- Validation errors MUST be mapped with the corresponding property names to ensure coherent naming between the consumed system and the service domain logic:
    ```go
    type (
        CompleteInvitationInput struct {
            UserAgent       string `header:"User-Agent"`
            RealIP          string
            InvitationToken string `path:"invitation_token"`
            Body            struct {
                Password string `json:"password"`
            }
        }
        ...
    )

    func (h *AuthHandler) CompleteInvitation(ctx context.Context, input *CompleteInvitationInput) (*CompleteInvitationOutput, error) {
        ...
        session, err := h.authService.CompleteInvitation(
            ctx,
            types.AuthServiceCompleteInvitationParams{
                InvitationToken: input.InvitationToken,
                Password:        input.Body.Password,
                UserAgent:       input.UserAgent,
                IP:              input.RealIP,
            })
        if err != nil {
            if validErr := valid.As(err); validErr != nil {
                return nil, validErr.Rename(map[string]string{
                    "InvitationToken": apierror.PathParam("invitation_token"),
                    "Password":        "password",
                })
            }
            return nil, err
        }
        ...
    }
    ```

### Errors

- Domain errors MUST be registered in `{module}/types/errors.go`
